## 算法的定义及特性

来源：https://weread.qq.com/web/bookDetail/b57320b071db572cb578fb5



算法（Algorithm）是为了解决某类问题而规定的一个有限长的操作序列。一个算法必须满足以下五个重要特性。

### 1 有穷性

一个算法必须总是在执行有穷步后结束，且每一步都必须在有穷时间内完成。

### 2 确定性

对于每种情况下所应执行的操作，在算法中都有确切的规定，不会产生二义性，使算法的执行者或阅读者都能明确其含义及如何执行。

### 3 可行性

算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现。

### 4 输入

一个算法有零个或多个输入。当用函数描述算法时，输入往往是通过形参表示的，在它们被调用时，从主调函数获得输入值。

### 5 输出

一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出的算法没有任何意义。当用函数描述算法时，输出多用返回值或引用类型的形参表示。





## 评价算法优劣的基本标准

### 1 正确性

在合理的数据输入下，能够在有限的运行时间内得到正确的结果。

### 2 可读性

一个好的算法，首先应便于人们理解和相互交流，其次才是机器可执行性。可读性强的算法有助于人们对算法的理解，而难懂的算法易于隐藏错误，且难于调试和修改。

### 3 健壮性

当输入的数据非法时，好的算法能适当地做出正确反应或进行相应处理，而不会产生一些莫名其妙的输出结果。

### 4 高效性

高效性包括时间和空间两个方面。时间高效是指算法设计合理，执行效率高，可以用时间复杂度来度量；空间高效是指算法占用存储容量合理，可以用空间复杂度来度量。时间复杂度和空间复杂度是衡量算法的两个主要指标





## 时间复杂度

一个算法的执行时间大致上等于其所有语句执行时间的总和，而语句的执行时间则为该条语句的重复执行次数和执行一次所需时间的乘积。

一条语句的重复执行次数称作**语句频度（Frequency Count）**。

一般情况下，算法中基本语句重复执行的次数是问题规模n的某个函数f(n)，算法的时间量度记作
$$
T(n)=O(f(n))
$$
它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称做算法的渐近时间复杂度，简称时间复杂度（Time Complexity）。

数学符号“O”的严格定义为：

若T(n)和f(n)是定义在正整数集合上的两个函数，则T(n)=O(f(n))表示存在正的常数C和$$ n0$$，使得当*n≥n0*时都满足$$ 0≤T(n)≤Cf(n)$$。

该定义说明了函数T(n)和f(n)具有相同的增长趋势，并且T(n)的增长至多趋向于函数f(n)的增长。符号“O”用来描述增长率的上限，它表示当问题规模$$ n>n0 $$时，算法的执行时间不会超过f(n)。



### 举例

分析算法时间复杂度的基本方法为：找出所有语句中语句频度最大的那条语句作为基本语句，计算基本语句的频度得到问题规模n的某个函数f(n)，取其数量级用符号“O”表示即可。具体计算数量级时，可以遵循以下定理。

定理1.1若$$ f(n)=amnm+am-1nm-1+…+a1n+a0 $$是一个m次多项式，则T(n)=O(nm)。

定理1.1说明，在计算算法时间复杂度时，**可以忽略所有低次幂项和最高次幂的系数**，这样可以简化算法分析，也体现出了增长率的含义。

若算法可用递归方法描述，则算法的时间复杂度通常可使用递归方程表示，此时将涉及递归方程求解问题。

有关递归算法的时间复杂度分析方法将在第3章给出。下面举例说明如何求非递归算法的时间复杂度。



### 常量阶示例

```c
{x++;s=0;}
```

两条语句频度均为1，算法的执行时间是一个与问题规模n无关的常数，所以算法的时间复杂度为T(n)=O(1)，称为**常量阶**

**实际上，如果算法的执行时间不随问题规模n的增加而增长，算法中语句频度就是某个常数。即使这个常数再大，算法的时间复杂度都是O(1)。**

例如，上面的程序作如下改动：

```c
for(i=0;i<10000;i++){x++;s=0;}
```

算法的时间复杂度仍然为O(1)



### 线性阶示例

```c
for(i=0;i<n;i++){x++;s=0;}
```

循环体内两条基本语句的频度均为f(n)=n，所以算法的时间复杂度为T(n)=O(n)，称为线性阶



### 平方阶示例

```c
x=0;y=0; 
for(k=1;k<=n;k++) 
	x++; 
for(i=1;i<=n;i++) 
	for(j=1;j<=n;j++) 
		y++;
```

对循环语句只需考虑循环体中语句的执行次数，以上程序段中频度最大的语句是（6），其频度为f(n)=n^2^ 所以该算法的时间复杂度为T(n)=O(n^2^)，称为平方阶。

多数情况下，当有若干个循环语句时，算法的时间复杂度是由最深层循环内的基本语句的频度f(n)决定的。



### 立方阶示例

```c
x=0; 
for(i=1;i<=n;i++) 
   for(j=1;j<=i;j++) 
       for(k=1;k<=j;k++) 
           x++;
```

上式子中x执行的次数为
$$
\sum_{n-1}^{1} \sum_{n-1}^{1} n-1 = (n^3-3n^2+4n-2)/4
$$
则该算法的时间复杂度为 T(n)=O(n^3^) 称为**立方阶**



### 对数阶示例

```c
for(i=1;i<=n;i=i*2)
{
    x++;
    s=0;
}
```

设循环体内两条基本语句的频度为$$ f(n) $$，则有$$ 2f(n)≤n$$ ，$$ f(n)≤log2n$$ ，所以算法的时间复杂度为$$ T(n)=O(log2n)$$ ，称为对数阶。

常见的时间复杂度按数量级递增排列依次为：常量阶$$ O(1)$$、对数阶$$O(log2n)$$、线性阶$$O(n)$$、线性对数阶$$O(nlog2n)$$、平方阶$$O(n^2)$$、立方阶$$O(n^3)$$、……、k次方阶$$O(n^k)$$、指数阶$$O(2^n)$$等。



不同数量级的时间复杂度性状如图1.7所示。一般情况下，随着$$n$$的增大，$$T(n)$$的增长较慢的算法为较优的算法。显然，时间复杂度为指数阶$$O(2^n)$$的算法效率极低，当n值稍大时就无法应用。应该尽可能选择使用多项式阶$$ O(n^k)$$的算法，而避免使用指数阶的算法。





## 最好、最坏和平均时间复杂度

- 称算法在最好情况下的时间复杂度为**最好时间复杂度**，指的是算法计算量可能达到的最小值；

- 称算法在最坏情况下的时间复杂度为**最坏时间复杂度**，指的是算法计算量可能达到的最大值；

- 算法的**平均时间复杂度**是指算法在所有可能情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。

对算法时间复杂度的度量，人们更关心的是最坏情况下和平均情况下的时间复杂度。然而在很多情况下，算法的平均时间复杂度难于确定。因此，通常只讨论算法在最坏情况下的时间复杂度，即分析在最坏情况下，算法执行时间的上界。

后面内容中讨论的时间复杂度，除特别指明外，均指**最坏情况下的时间复杂度**。



## 空间复杂度

关于算法的存储空间需求，类似于算法的时间复杂度，我们采用渐近**空间复杂度**（Space Complexity）作为算法所需存储空间的量度，简称空间复杂度，它也是问题规模n的函数，记作：
$$
S(n)=O(f (n))
$$
一般情况下，一个程序在机器上执行时，除了需要寄存本身所用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的辅助存储空间。其中，对于输入数据所占的具体存储量取决于问题本身，与算法无关，这样只需分析该算法在实现时所需要的辅助空间就可以了。

**若算法执行时所需要的辅助空间相对于输入数据量而言是个常数，则称这个算法为原地工作**，**辅助空间为O(1)**，本节中前面的示例都是如此。有的算法需要占用临时的工作单元数与问题规模n有关，如第8章介绍的**归并排序算法**就属于这种情况。



例如：算法1仅需要另外借助一个变量$$t$$，与问题规模$$n$$大小无关，所以其空间复杂度为$$O(1)$$。算法2需要另外借助一个大小为n的辅助数组$$b$$，所以其空间复杂度为$$O(n)$$。

对于一个算法，其时间复杂度和空间复杂度往往是相互影响的，当追求一个较好的时间复杂度时，可能会导致占用较多的存储空间，即可能会使空间复杂度的性能变差，反之亦然。不过，通常情况下，鉴于运算空间较为充足，人们都以算法的时间复杂度作为算法优劣的衡量指标。